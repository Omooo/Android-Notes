---
TCP/IP 详解卷一 协议
---

#### 目录

1. 第十章 用户数据报协议和 IP 分片
2. 第十二章 传输控制协议
3. 第十三章 TCP 连接管理
3. 第十四章 TCP 超时与重传
3. 第十五章 TCP 数据流与窗口管理
3. 第十六章 TCP 拥塞控制

#### 用户数据报协议

UDP 是一种保留消息边界的简单的面向数据报的传输层协议。它不提供差错纠正、队列管理、重复消除、流量控制和拥塞控制。它提供差错检测，包含我们在传输层中碰到的第一个端到端校验和。

UDP 不提供差错纠正，它把应用程序传给 IP 层的数据发送出去，但是并不保证它们能够到达目的地。另外，没有协议机制防止高速 UDP 流量对其他网络用户的消极影响。考虑到这种可靠性和保护性的缺失，我们可能会认为使用 UDP 一点好处都没有，但是这是不对的，因为它的无连接性，它要比其他传输层协议使用更少的开销。

UDP 数据报是包含 8 个字节的头部和负载数据，头部包含原端口号、目的端口号、长度、校验和，分别是 2 字节。

#### 传输控制协议

TCP 提供了一种面向连接的、可靠的字节流服务。面向连接是指使用 TCP 的两个应用程序在收发数据之前需要通过 “三次握手” 来建立逻辑连接。TCP 提供一种字节流抽象概念给应用程序使用，这种设计方案的结果是，没有由 TCP 自动插入的记录标志或消息边界。如果应用程序在一端写入 10 字节、随后写入 20 字节，最后写入 50 字节，那么在连接的另一端应用程序是不知道每次写入的字节是多少的，它可以以每次 20 字节读取四次也可以一次性读入 80 字节。TCP 根本不会解读字节流里的字节内容，它不知道正在交换的数据字节是不是二进制数据还是其他 ASCII 等等。对这个字节流的读取取决于连接中每个端点的应用程序。

TCP 维持了一个强制的校验和，该校验和涉及它的头部、任何相关应用程序数据和 IP 头部的所有字段。如果一个带无效检验和的报文段到达，那么 TCP 会丢弃它，不为被丢弃的分组发送任何确认。然后，TCP 接收端可能会对一个以前的（已经确认的）报文段进行确认，以帮助发送方计算它的拥塞控制。

当 TCP 发送一组报文段时，它通常设置一个重传计时器，等待对方的确认接收。TCP 不会为每个报文段设置一个不同的重传计时器。相反，发生一个窗口的数据，它只设置一个计时器，当 ACK 到达时再更新超市。如果有一个确认没有及时接收到，这个报文段就会被重传。

TCP 给应用程序提供一种双工服务，这就是说数据可向两个方向流动，两个方向互相独立。因此，连接的每个端点必须对每个方向维持数据流的一个序列号。使用序列号，一个 TCP 接收端可丢弃重复的报文段和记录以杂乱次序到达的报文段。TCP 使用 IP 来传递它的报文段，IP 不提供重复消除或保证次序正确的功能。然后，因为 TCP 是一个字节流协议，TCP 绝不对以杂乱的次序给接收应用程序发送数据。因此，TCP 接收端可能会被迫先保持大序列号的数据不交给应用程序，知道缺失的小序列号报文段到达。

TCP 报文段包含 20 字节（不带选项）的头部和负载。

#### TCP 连接管理

TCP 连接建立过程：

1. 客户端发送一个 SYN 报文段（即一个在 TCP 头部的 SYN 位字段置位的 TCP/IP 数据包），并指明自己想要连接的端口号和它的客户端初始序列号（记为 ISN(c)）。通常，客户端还会借此发送一个或多个选项，客户端发送的这个 SYN 报文段称作段 1。
2. 服务器也发送自己的 SYN 报文段作为响应，并包含了它的初始序列号（记做 ISN(s)），该段成为段 2。此外，为了确认客户端的 SYN，服务端将其包含的 ISN(c) 数值加 1 后作为返回的 ACK 数值。因此，每发送一个 SYN，序列号就会自动加 1，这样如果出现丢失的情况，该 SYN 段将会重传。
3. 为了确认服务端的 SYN，客户端将 ISN(s) 的数值加 1 后作为返回的 ACK 数值，称为段 3。

通过发送上述 3 个报文段就能够完成一个 TCP 连接的建立。它们也被称作三次握手，三次握手的目的不仅在于让通信双方了解一个连接正在建立，还在于利用数据包的选项来承载特殊信息，交换初始序列号。

TCP 连接的任何一方都能够发起一个关闭操作，连接关闭过程：

1. 连接的主动关闭者发送一个 FIN 段指明接收者希望看到自己当前的序列号（如 K）。FIN 段还包含一个 ACK 段用来确认对方最近一次发来的数据（如 L）。
2. 连接的被动关闭者将 K 的数值加 1 作为响应的 ACK 值，以表明它已经成功接收到主动关闭者发送的 FIN。此时，上层的应用程序会被告知连接的另一端已经提出了关闭的请求。通常，这将导致应用程序发起自己的关闭操作。接着，被动关闭者将身份转变为主动关闭者，发生自己的 FIN，该报文段的序列号为 L。
3. 为了完成连接的关闭，最后发送的报文段还包含一个 ACK 用于确认上一个 FIN。值得注意的是，如果出现了 FIN 丢失的情况，那么发送方将重新传输直到接收到一个 ACK 确认为止。

![](https://s2.loli.net/2022/02/08/lVHCvTQOKm3JyYk.png)

三次握手和四次挥手的状态变迁图：

![](https://s2.loli.net/2022/02/08/LniMrIdNpt7QOWZ.png)

连接队列：

在被用于应用程序之前新的连接可能会处于以下两种状态：

1. 连接尚未完成但是已经接收到了 SYN（也就是处于 SYN_RCVD 状态）
2. 连接已经完成了三次握手并且处于 ESTABLISHED 状态，但是还未被应用程序接受

在 Linux 中：

1. 当一个连接请求到达（即 SYN 报文段），将会检查系统范围的参数 net.ipv4.tcp.max_syn_backlog（默认为 1000）。如果处于 SYN_RCVD 状态的连接数目超过了这一阈值，进入的连接将会被拒绝。
2. 而已完成三次握手但未被应用程序接受的连接，会放入未完成连接队列里，该队列默认值为 128。

SYN 泛洪是一种 TCP 拒绝服务攻击，在这种攻击中一个或多个恶意的客户端产生一系列 TCP 连接尝试（SYN 报文段），并将它们发送给一台服务器，它们通常采用 "伪造" 的（例如，随机选择）源 IP 地址。服务器会为每一条连接分配一定数量的连接资源。由于连接尚未完全建立，服务器为了维护大量的半打开连接会耗尽自身内存后拒绝为后续的合法连接请求服务。

因为区分合法的连接尝试与 SYN 泛洪并不是一件容易的事情，所以抵御上述攻击存在一定的难度。一种针对此问题的机制被称作 SYN cookies。SYN cookies 的主要思想是，当一个 SYN 到达时，这条连接存储的大部分信息都会被编码并保存在 SYN+ACK 报文段的序列号字段。采用 SYN cookies 的目标主机不需要为进入的连接请求分配任何存储资源，只有当 SYN+ACK 报文段本身被确认后才会分配真正的内存。在这种情况下，所有重要的连接参数都能够重新获得，同时连接也能过被设置为 ESTABLISHED 状态。

#### TCP 超时与重传

由于下层网络层可能出现丢失、重复或失序包的情况，TCP 协议提供可靠的数据传输服务。为保证数据传输的正确性，TCP 重传其认为已丢失的包。TCP 根据接收端返回至发送端的一系列确认信息来判断是否出现丢包。当数据段或者确认信息丢失，TCP 启动重传操作，重传尚未确认的数据。TCP 拥有两套机制来完成重传，一是基于时间，二是基于确认信息的构成。第二种方法通常比第一种更有效。

TCP 在发送数据时会设置一个计时器，若计时器超时仍未收到数据确认信息，则会引发相应的超时或基于计时器的重传操作，计时器超时称为重传超时（RTO）。另一种方式的重传称为快速重传，通常发生在没有延时的情况下。若 TCP 累积确认无法返回新的 ACK，或者当 ACK 包含的选择确认信息（SACK）表明出现失序报文段时，快速重传会推断出现丢包。

这里我们探讨如何根据某个连接的 RTT 来设置 RTO，基于计时器的重传机制、以及 TCP 快速重传操作。另外我们也会看到 SACK 怎样帮助确认丢失数据、失序和重复 IP 包对 TCP 行为的影响，以及 TCP 重传时改变包大小的方法。

**基于计时器的重传：**

一旦 TCP 发送端得到了基于时间变化的 RTT 测量值，就会据此设置 RTO，发送报文段时应确保重传计时器设置合理。在设定计时器前，需记录被计时的报文段序列号，若及时收到了该报文段的 ACK，那么计时器被取消。之后发送端发送一个新的数据包时，需设定一个新的计时器，并记录新的序列号。因此每一个 TCP 连接的发送端不断地设定和取消一个重传计时器；如果没有数据丢失，则不会出现计时器超时。

若在连接设定的 RTO 内，TCP 没有收到被计时报文段的 ACK，将会触发超时重传。TCP 将超时重传视为相当重要的事件，当发生这种情况时，它通过降低当前数据发送率来对此进行快速响应。实现它有两种方法：第一种方法是基于拥塞控制机制减少发送窗口大小；另一种方法为每当一个重传报文段被再次重传时，则增大 RTO 的退避因子，特别是当同一个报文段出现多次重传时，RTO 值乘上 y 来形成新的超时退避值：
$$
RTO = yRTO
$$
在通常环境下，y 值为 1。随着多次重传，y 成倍增长：2、4、8 等等。通常 y 不能超过最大退避因子，默认值是 120s。一旦接收到相应的 ACK，y 会重置为 1。

**快速重传**

快速重传机制是基于接收端的反馈信息来引发重传，而非重传计时器的超时。因此与超时重传相比，快速重传能更加及时有效的修复丢包情况。典型的 TCP 同时实现了两者。在讨论快速重传之前，需要先了解当接收到失序报文段时，TCP 需要立即生成确认信息（重复 ACK），并且失序情况表明在后续数据到达前出现了丢段，即接收端缓存出现了空缺。发送端的工作即为尽快的、高效的填补该空缺。

当失序数据到达时，重复 ACK 应立即返回，不能延时发送。原因在于使发送端尽早得知有失序报文段，并告诉其空缺在哪。当采用 SACK 时，重复 ACK 通常也包含 SACK 信息，利用该信息可以获知多个空缺。

快速重传算法可以概括为：TCP 发送端在观测到至少 3 个重复的 ACK 后，即重传可能丢失的数据分组，而不必等到重传计时器超时。当然也可以同时发生新的数据。根据重复 ACK 推断的丢包通常与网络拥塞有关，因此伴随快速重传应触发拥塞控制机制。不采用 SACK 时，在接收到有效 ACK 前至多只能重传一个报文段。采用 SACK，ACK 可包含额外信息，使得发送端在每个 RTT 时间内可以填补多个空缺。

**带选择确认的重传**

随着选择确认选项的标准化，TCP 接收端可提供 SACK 功能，通过 TCP 头部累积的 ACK 号字段来描述其接收到的数据。

TCP 发送端的任务是通过重传丢失的数据来填补接收端缓存中的空缺，但同时也要尽可能保证不重传已正确接收到的数据。在很多环境下，合理采用 SACK 信息能更快的实现空缺填补，且能减少不必要的重传，原因在于其在一个 RTT 内能获知多个空缺。当采用 SACK 选项时，一个 ACK 可包含三四个告知失序数据的 SACK 信息。每个 SACK 信息包含 32 位的序列号，代表接收端存储的失序数据的起始至最后一个序列号。

#### TCP 数据流与窗口管理

流量控制：

它通过动态调节窗口大小来控制发送端发送速率，确保接收端不会溢出。

滑动窗口：

TCP 连接的每一端都可收发数据。连接的收发数据量是通过一组窗口结构来维护的。每个 TCP 活动连接的两端都维护一个发送窗口结构和接受窗口机制。

发送窗口如下：

![](https://s2.loli.net/2022/02/10/wHkVzCv7J5Pb6d9.png)

TCP 发送端滑动窗口结构记录了已确认、在传以及还未传的数据的序列号。提供窗口的大小是由接收端返回的 ACK 中的窗口大小字段控制的。

接收窗口如下：

![](https://s2.loli.net/2022/02/10/tKRWfawIT2LhEZM.png)

TCP 接收端滑动窗口结构帮助了解其下次应接收的数据序列号，若接收到的数据序列号在窗口内，则可以存储，否则丢弃。

#### TCP 拥塞控制
