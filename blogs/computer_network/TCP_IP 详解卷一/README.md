---
TCP/IP 详解卷一 协议
---

#### 目录

1. 第十章 用户数据报协议和 IP 分片
2. 第十二章 传输控制协议
3. 第十三章 TCP 连接管理
3. 第十四章 TCP 超时与重传
3. 第十五章 TCP 数据流与窗口管理
3. 第十六章 TCP 拥塞控制

#### 用户数据报协议

UDP 是一种保留消息边界的简单的面向数据报的传输层协议。它不提供差错纠正、队列管理、重复消除、流量控制和拥塞控制。它提供差错检测，包含我们在传输层中碰到的第一个端到端校验和。

UDP 不提供差错纠正，它把应用程序传给 IP 层的数据发送出去，但是并不保证它们能够到达目的地。另外，没有协议机制防止高速 UDP 流量对其他网络用户的消极影响。考虑到这种可靠性和保护性的缺失，我们可能会认为使用 UDP 一点好处都没有，但是这是不对的，因为它的无连接性，它要比其他传输层协议使用更少的开销。

UDP 数据报是包含 8 个字节的头部和负载数据，头部包含原端口号、目的端口号、长度、校验和，分别是 2 字节。

#### 传输控制协议

TCP 提供了一种面向连接的、可靠的字节流服务。面向连接是指使用 TCP 的两个应用程序在收发数据之前需要通过 “三次握手” 来建立逻辑连接。TCP 提供一种字节流抽象概念给应用程序使用，这种设计方案的结果是，没有由 TCP 自动插入的记录标志或消息边界。如果应用程序在一端写入 10 字节、随后写入 20 字节，最后写入 50 字节，那么在连接的另一端应用程序是不知道每次写入的字节是多少的，它可以以每次 20 字节读取四次也可以一次性读入 80 字节。TCP 根本不会解读字节流里的字节内容，它不知道正在交换的数据字节是不是二进制数据还是其他 ASCII 等等。对这个字节流的读取取决于连接中每个端点的应用程序。

TCP 维持了一个强制的校验和，该校验和涉及它的头部、任何相关应用程序数据和 IP 头部的所有字段。如果一个带无效检验和的报文段到达，那么 TCP 会丢弃它，不为被丢弃的分组发送任何确认。然后，TCP 接收端可能会对一个以前的（已经确认的）报文段进行确认，以帮助发送方计算它的拥塞控制。

当 TCP 发送一组报文段时，它通常设置一个重传计时器，等待对方的确认接收。TCP 不会为每个报文段设置一个不同的重传计时器。相反，发生一个窗口的数据，它只设置一个计时器，当 ACK 到达时再更新超市。如果有一个确认没有及时接收到，这个报文段就会被重传。

TCP 给应用程序提供一种双工服务，这就是说数据可向两个方向流动，两个方向互相独立。因此，连接的每个端点必须对每个方向维持数据流的一个序列号。使用序列号，一个 TCP 接收端可丢弃重复的报文段和记录以杂乱次序到达的报文段。TCP 使用 IP 来传递它的报文段，IP 不提供重复消除或保证次序正确的功能。然后，因为 TCP 是一个字节流协议，TCP 绝不对以杂乱的次序给接收应用程序发送数据。因此，TCP 接收端可能会被迫先保持大序列号的数据不交给应用程序，知道缺失的小序列号报文段到达。

TCP 报文段包含 20 字节（不带选项）的头部和负载。

#### TCP 连接管理

TCP 连接建立过程：

1. 客户端发送一个 SYN 报文段（即一个在 TCP 头部的 SYN 位字段置位的 TCP/IP 数据包），并指明自己想要连接的端口号和它的客户端初始序列号（记为 ISN(c)）。通常，客户端还会借此发送一个或多个选项，客户端发送的这个 SYN 报文段称作段 1。
2. 服务器也发送自己的 SYN 报文段作为响应，并包含了它的初始序列号（记做 ISN(s)），该段成为段 2。此外，为了确认客户端的 SYN，服务端将其包含的 ISN(c) 数值加 1 后作为返回的 ACK 数值。因此，每发送一个 SYN，序列号就会自动加 1，这样如果出现丢失的情况，该 SYN 段将会重传。
3. 为了确认服务端的 SYN，客户端将 ISN(s) 的数值加 1 后作为返回的 ACK 数值，称为段 3。

通过发送上述 3 个报文段就能够完成一个 TCP 连接的建立。它们也被称作三次握手，三次握手的目的不仅在于让通信双方了解一个连接正在建立，还在于利用数据包的选项来承载特殊信息，交换初始序列号。

TCP 连接的任何一方都能够发起一个关闭操作，连接关闭过程：

1. 连接的主动关闭者发送一个 FIN 段指明接收者希望看到自己当前的序列号（如 K）。FIN 段还包含一个 ACK 段用来确认对方最近一次发来的数据（如 L）。
2. 连接的被动关闭者将 K 的数值加 1 作为响应的 ACK 值，以表明它已经成功接收到主动关闭者发送的 FIN。此时，上层的应用程序会被告知连接的另一端已经提出了关闭的请求。通常，这将导致应用程序发起自己的关闭操作。接着，被动关闭者将身份转变为主动关闭者，发生自己的 FIN，该报文段的序列号为 L。
3. 为了完成连接的关闭，最后发送的报文段还包含一个 ACK 用于确认上一个 FIN。值得注意的是，如果出现了 FIN 丢失的情况，那么发送方将重新传输直到接收到一个 ACK 确认为止。

![](https://s2.loli.net/2022/02/08/lVHCvTQOKm3JyYk.png)

三次握手和四次挥手的状态变迁图：

![](https://s2.loli.net/2022/02/08/LniMrIdNpt7QOWZ.png)

连接队列：

在被用于应用程序之前新的连接可能会处于以下两种状态：

1. 连接尚未完成但是已经接收到了 SYN（也就是处于 SYN_RCVD 状态）
2. 连接已经完成了三次握手并且处于 ESTABLISHED 状态，但是还未被应用程序接受

在 Linux 中：

1. 当一个连接请求到达（即 SYN 报文段），将会检查系统范围的参数 net.ipv4.tcp.max_syn_backlog（默认为 1000）。如果处于 SYN_RCVD 状态的连接数目超过了这一阈值，进入的连接将会被拒绝。
2. 而已完成三次握手但未被应用程序接受的连接，会放入未完成连接队列里，该队列默认值为 128。

SYN 泛洪是一种 TCP 拒绝服务攻击，在这种攻击中一个或多个恶意的客户端产生一系列 TCP 连接尝试（SYN 报文段），并将它们发送给一台服务器，它们通常采用 "伪造" 的（例如，随机选择）源 IP 地址。服务器会为每一条连接分配一定数量的连接资源。由于连接尚未完全建立，服务器为了维护大量的半打开连接会耗尽自身内存后拒绝为后续的合法连接请求服务。

因为区分合法的连接尝试与 SYN 泛洪并不是一件容易的事情，所以抵御上述攻击存在一定的难度。一种针对此问题的机制被称作 SYN cookies。SYN cookies 的主要思想是，当一个 SYN 到达时，这条连接存储的大部分信息都会被编码并保存在 SYN+ACK 报文段的序列号字段。采用 SYN cookies 的目标主机不需要为进入的连接请求分配任何存储资源，只有当 SYN+ACK 报文段本身被确认后才会分配真正的内存。在这种情况下，所有重要的连接参数都能够重新获得，同时连接也能过被设置为 ESTABLISHED 状态。

#### TCP 超时与重传

由于下层网络层可能出现丢失、重复或失序包的情况，TCP 协议提供可靠的数据传输服务。为保证数据传输的正确性，TCP 重传其认为已丢失的包。TCP 根据接收端返回至发送端的一系列确认信息来判断是否出现丢包。当数据段或者确认信息丢失，TCP 启动重传操作，重传尚未确认的数据。TCP 拥有两套机制来完成重传，一是基于时间，二是基于确认信息的构成。第二种方法通常比第一种更有效。

TCP 在发送数据时会设置一个计时器，若计时器超时仍未收到数据确认信息，则会引发相应的超时或基于计时器的重传操作，计时器超时称为重传超时（RTO）。另一种方式的重传称为快速重传，通常发生在没有延时的情况下。若 TCP 累积确认无法返回新的 ACK，或者当 ACK 包含的选择确认信息（SACK）表明出现失序报文段时，快速重传会推断出现丢包。

这里我们探讨如何根据某个连接的 RTT 来设置 RTO，基于计时器的重传机制、以及 TCP 快速重传操作。另外我们也会看到 SACK 怎样帮助确认丢失数据、失序和重复 IP 包对 TCP 行为的影响，以及 TCP 重传时改变包大小的方法。

**基于计时器的重传：**

一旦 TCP 发送端得到了基于时间变化的 RTT 测量值，就会据此设置 RTO，发送报文段时应确保重传计时器设置合理。在设定计时器前，需记录被计时的报文段序列号，若及时收到了该报文段的 ACK，那么计时器被取消。之后发送端发送一个新的数据包时，需设定一个新的计时器，并记录新的序列号。因此每一个 TCP 连接的发送端不断地设定和取消一个重传计时器；如果没有数据丢失，则不会出现计时器超时。

若在连接设定的 RTO 内，TCP 没有收到被计时报文段的 ACK，将会触发超时重传。TCP 将超时重传视为相当重要的事件，当发生这种情况时，它通过降低当前数据发送率来对此进行快速响应。实现它有两种方法：第一种方法是基于拥塞控制机制减少发送窗口大小；另一种方法为每当一个重传报文段被再次重传时，则增大 RTO 的退避因子，特别是当同一个报文段出现多次重传时，RTO 值乘上 y 来形成新的超时退避值：
$$
RTO = yRTO
$$
在通常环境下，y 值为 1。随着多次重传，y 成倍增长：2、4、8 等等。通常 y 不能超过最大退避因子，默认值是 120s。一旦接收到相应的 ACK，y 会重置为 1。

**快速重传**

快速重传机制是基于接收端的反馈信息来引发重传，而非重传计时器的超时。因此与超时重传相比，快速重传能更加及时有效的修复丢包情况。典型的 TCP 同时实现了两者。在讨论快速重传之前，需要先了解当接收到失序报文段时，TCP 需要立即生成确认信息（重复 ACK），并且失序情况表明在后续数据到达前出现了丢段，即接收端缓存出现了空缺。发送端的工作即为尽快的、高效的填补该空缺。

当失序数据到达时，重复 ACK 应立即返回，不能延时发送。原因在于使发送端尽早得知有失序报文段，并告诉其空缺在哪。当采用 SACK 时，重复 ACK 通常也包含 SACK 信息，利用该信息可以获知多个空缺。

快速重传算法可以概括为：TCP 发送端在观测到至少 3 个重复的 ACK 后，即重传可能丢失的数据分组，而不必等到重传计时器超时。当然也可以同时发生新的数据。根据重复 ACK 推断的丢包通常与网络拥塞有关，因此伴随快速重传应触发拥塞控制机制。不采用 SACK 时，在接收到有效 ACK 前至多只能重传一个报文段。采用 SACK，ACK 可包含额外信息，使得发送端在每个 RTT 时间内可以填补多个空缺。

**带选择确认的重传**

随着选择确认选项的标准化，TCP 接收端可提供 SACK 功能，通过 TCP 头部累积的 ACK 号字段来描述其接收到的数据。

TCP 发送端的任务是通过重传丢失的数据来填补接收端缓存中的空缺，但同时也要尽可能保证不重传已正确接收到的数据。在很多环境下，合理采用 SACK 信息能更快的实现空缺填补，且能减少不必要的重传，原因在于其在一个 RTT 内能获知多个空缺。当采用 SACK 选项时，一个 ACK 可包含三四个告知失序数据的 SACK 信息。每个 SACK 信息包含 32 位的序列号，代表接收端存储的失序数据的起始至最后一个序列号。

#### TCP 数据流与窗口管理

流量控制：

它通过动态调节窗口大小来控制发送端发送速率，确保接收端不会溢出。

滑动窗口：

TCP 连接的每一端都可收发数据。连接的收发数据量是通过一组窗口结构来维护的。每个 TCP 活动连接的两端都维护一个发送窗口结构和接受窗口机制。

发送窗口如下：

![](https://s2.loli.net/2022/02/10/wHkVzCv7J5Pb6d9.png)

TCP 发送端滑动窗口结构记录了已确认、在传以及还未传的数据的序列号。提供窗口的大小是由接收端返回的 ACK 中的窗口大小字段控制的。

接收窗口如下：

![](https://s2.loli.net/2022/02/10/tKRWfawIT2LhEZM.png)

TCP 接收端滑动窗口结构帮助了解其下次应接收的数据序列号，若接收到的数据序列号在窗口内，则可以存储，否则丢弃。

#### TCP 拥塞控制

拥塞控制是 TCP 通信的每一方需要执行的一系列行为。这些行为由特定算法规定，用于防止网络因为大规模的通信负载而瘫痪。其基本方法是当有理由认为网络即将进入拥塞状态（或者已经由于拥塞而出现路由器丢包情况）时减缓 TCP 传输。TCP 拥塞控制的难点在于怎样准确的判断何时需要减缓且如何减缓 TCP 传输，以及何时恢复其原有的速度。

路由器因无法处理高速率到达的流量而被迫丢弃数据信息的现象称为拥塞。当路由器处于上述状态时，我们就说出现了拥塞。为了避免和在一定程度上缓解这种状况，TCP 通信的每一方实行拥塞控制机制。

**TCP 拥塞检测**

前面我们已经知道，TCP 如何利用计时器、确认以及选择确认机制来检测丢包和恢复传输。当有丢包情况出现时，TCP 的任务是重传这些数据包。现在我们关心的是，当观测到丢包后，TCP 还做了哪些工作，特别是它如何识别这就是已出现拥塞的信号，进而需要执行减速操作。

一个待解决的问题是，如何减缓 TCP 发送？

前面我们提到过，根据接收方剩余缓存空间大小，在 TCP 头部设置了通知窗口大小字段，该数值是 TCP 发送方调节发送速率的依据。进一步说，当接收速率或网络传输速率过慢时，我们需要降低发送速率。为实现上述操作，基于对网络传输能力的估计，可以在发送端引入一个窗口控制变量，确保发送窗口大小不超过接收端接收能力和网络传输能力，即 TCP 发送端的发送速率等于接收速率和传输速率两者中较小值。

反应网络传输能力的变量称为用色窗口，记做 cwnd。因此，发送端实际可用窗口 W = ：
$$
W = min(cwnd, awnd)
$$
TCP 通过与接收端交换一个数据包就能获得 awnd 的值，但是 cwnd 的值并不好确认。因为在连接建立之初，还无法获知可用的传输资源。显而易见，获得 cwnd 最佳值的唯一办法就是以越来越快的速率不断发送数据，直至出现数据丢包为止。这时考虑立即以可用的最大速率发送（受 awnd 限制），或是慢速启动发送。由于多个 TCP 连接共享一个网络传输路径，以全速启动会影响其他连接的传输性能，所以通常会有特定的算法来避免过快启动，直至稳定传输后才会运行相应的其他算法。

下面我们讨论 TCP 的两个核心算法：慢启动和拥塞避免。这两个算法不是同时运行的，在任意给定时刻，TCP 只运行一个算法。

**慢启动**

当一个新的 TCP 连接建立或检测到由重传超时（RTO）导致的丢包时，需要执行慢启动。慢启动的目的是，使 TCP 在用拥塞避免探寻更多可用带宽之前得到 cwnd 值。通常，TCP 在建立新连接时执行慢启动，直至有丢包时，执行拥塞避免算法进入稳定状态。

在传输初始阶段，由于未知网络传输能力，需要缓慢探测可用传输资源，防止短时间内大量数据注入导致拥塞。慢启动算法正是针对这一问题而设计。在数据传输之初或者重传计时器检测到丢包后，需要执行慢启动。

![](https://s2.loli.net/2022/02/10/fjtSxGQUyVePZFE.png)

以上就是经典的慢启动算法操作，在没有 ACK 延时的情况下，每接收到一个好的 ACK 就意味着发送方可以发送两个新的数据包（左），这会使得发送方窗口随时间呈指数增长（右上方曲线）。当发生 ACK 延时，如每隔一个数据包生成一个 ACK，cwnd 仍以指数增长，但涨幅较小（右下方曲线）。

**拥塞避免**

但是 cwnd 不可能无限指数级增长，当达到了慢启动阈值时，就意味着可能有更多可用的传输资源。如果立即全部占用这些资源，将会使共享路由器队列的其他连接出现严重的丢包和重传情况，进而导致整个网络性能不稳定。

为了得到更多的传输资源而不影响其他连接传输，TCP 实现了拥塞避免算法。一旦确立慢启动阈值，TCP 会进入拥塞状态阶段，cwnd 将进行线性增长。

![](https://s2.loli.net/2022/02/10/qeiRf78LmhZw41y.png)

以上就是拥塞避免算法操作，若没有 ACK 延时发生，每接收一个好的 ACK，就意味着发送方可继续发生 1/W 个新的数据包。发送窗口随时间近似呈线性增长（右上方曲线）。当有 ACK 延时，如每隔一个数据包生成一个 ACK，cwnd 仍近似呈线性增长，只是增幅较小（右下方曲线）。

**总结**

TCP 被设计为互联网中主要的可靠传输协议。虽然其最初的设计包含了流量控制功能，能够在接收方无法跟上时降低发送方的速度，但是最初没有提供办法从防止发送方淹没双方之间的网络。为了控制发送方的攻击性行为，TCP 开发了慢启动与拥塞避免算法，从而避免了因为网络拥塞而造成的丢包问题。这些算法都依赖于使用一个隐含的信号、数据包丢失以及拥塞的指示。当检测到丢包时就会触发这些算法，无论是通过快速重传算法还是超时重传。

慢启动与拥塞避免通过在发送方设置一个拥塞窗口来实现对其操作的控制。该拥塞窗口将其与传统的窗口一起使用（基于接收方提供的窗口广告）。一个标准的 TCP 会将其窗口的最小值限定为 2.随着时间的增长，慢启动要求拥塞窗口的数值指数地增长，而拥塞避免则会随着时间的推移而线性增长。在任何时刻都只能选择两种算法中的一种运行，而做出这一选择需要比较拥塞窗口当前的数值与慢启动的阈值。如果拥塞窗口超过了阈值，那么采用拥塞避免；否则使用慢启动。慢启动起初只在建立 TCP 连接以及因超时而重新启动后使用，它也适用于连接长时间处于空闲状态的情况。在整个连接的过程中，慢启动的阈值会动态的进行调整。
